[{"content":"Antes de empezar El presente art√≠culo no es de mi autor√≠a si no de Pantelis Roditis (proditis@echothrust.com), esto es solamente una traducci√≥n realizada con el permiso del autor. El art√≠culo original en ingl√©s lo puedes encontrar en el siguiente enlace: Environment variables and how to get them - Pantelis Roditis.\nMe pareci√≥ buena idea traducirlo dado que gracias a su lectura me permiti√≥ encontrar las banderas de entorno de la plataforma echoCTF.RED, adem√°s de aprender m√°s acerca del comportamiento de las variables de entorno.\nIntroducci√≥n  Una variable de entorno es un valor nombrado que puede ser accedido y puede afectar el comportamiento de un proceso ejecutado en una computadora.\n wikipedia   Piensa en las variables como nombres simb√≥licos que damos a los valores para evitar recordarlos. Imagina que usas el n√∫mero 3.1415926535897932384626433 constantemente, a menos que seas una especie de robot, va a ser dif√≠cil recordarlo. Entonces, le asignas un nombre al valor pi=3.1415926535897932384626433 y ahora cada vez que quieras usar el valor simplemente usas el nombre simb√≥lico pi, en vez de la secuencia gigante de n√∫meros.\nEn este documento, se describir√° el uso de variables de entorno, c√≥mo se puede acceder a ellas, manipularlas y aprovecharlas para ingenieros de seguridad tanto ofensivos como defensivos.\nPorque nos importa Entonces, ¬øpor qu√© son importantes las variables de entorno desde la perspectiva de seguridad?\nSol√≠a ‚Äã‚Äã‚Äã‚Äãser (en los viejos tiempos lol) que las variables de entorno eran visibles para todos y, como regla, la mayor√≠a de los desarrolladores no las usaban para almacenar informaci√≥n confidencial. Sin embargo, a medida que crec√≠a la adopci√≥n de variables de entorno, tambi√©n aumentaba la necesidad de comenzar a almacenar informaci√≥n un poco m√°s confidencial. Por lo tanto, se agreg√≥ la capacidad de ocultar las variables de entorno de otros usuarios y procesos a algunos, si no a todos, los sistemas UNIX y similares a UNIX (como Linux) y, por lo tanto, se limit√≥ su superficie de ataque.\nAhora, nos hemos mudado a la era de los contenedores y las variables de entorno tienen un nuevo significado. Echa un vistazo r√°pido a Docker Hub y ver√°s millones de im√°genes que usan variables de entorno que contienen informaci√≥n confidencial. Desde nombre de usuario, contrase√±as, claves de cifrado, tokens de autenticaci√≥n, claves del sistema, hay una imagen con un uso de variable de entorno para adaptarse a cualquier imaginaci√≥n\u0026hellip;\nComo ingeniero de seguridad ofensivo o defensivo, saber c√≥mo encontrar lo que est√° expuesto y poder acceder a esta informaci√≥n es una habilidad casi necesaria.\nY no nos enga√±emos, esta es definitivamente una habilidad que apreciar√°s mientras juegas en nuestra plataforma en l√≠nea echoCTF.RED, ya que las variables de entorno parecen m√°s dif√≠ciles de obtener que el acceso del usuario root\u0026hellip;\nComo funcionan Usaremos una variedad de sistemas para examinar c√≥mo se comportan las variables de entorno. Cuando no se menciona un sistema o shell, se puede asumir con seguridad que se trata de bash.\nComencemos definiendo y usando algunas variables:\n$ myint=1 $ mystring=\u0026#34;This is a long string\u0026#34; $ echo $myint 1 $ echo $mystring This is a long string Si desde la misma terminal vuelves a ejecutar bash notar√°s que las variables han desaparecido.\n$ echo $mystring This is a long string $ bash $ echo $mystring $ Lo mismo suceder√° si abres otra terminal e intentas acceder a la variable. Entonces, ¬øpor qu√© pasa eso?\nLas variables tienen efecto solo en la sesi√≥n actual. Para que una variable est√© disponible en los comandos y sesiones subsecuentes que se generan a partir de uno existente, tenemos que \u0026ldquo;exportarlos\u0026rdquo; (usando export en la terminal).\n$ export mystring $ bash $ echo $mystring This is a long string Muchos comandos y la mayor√≠a de las shells usan archivos de configuraci√≥n cuando se inician (por ejemplo, ~/.bashrc) para instruirles sobre la configuraci√≥n de variables. Adem√°s, algunos comandos establecen sus propias variables para ayudar a los comandos subsecuentes (por ejemplo, USER establecido por el inicio de sesi√≥n, etc.).\nVariables Docker Comprender el concepto de visibilidad de variables es especialmente importante en situaciones en las que las variables de entorno se configuran desde el inicio del sistema (como los contenedores docker), lo que, en determinadas condiciones, hace que se exporten al espacio de proceso global.\nNo profundizaremos en los detalles espec√≠ficos de docker, s√≥lo en la medida en que sea necesario para comprender las variables.\nVeamos un ejemplo con variables docker:\n$ docker run -it -e \u0026#34;myvar=myvalue\u0026#34; bash root@envlab: / # echo $myvar myvalue root@envlab: / #  Una cosa que notamos es que esta variable se exporta:\nroot@envlab: / # bash  root@envlab: / # echo $myvar myvalue Incluso si comenzamos un inicio de sesi√≥n bash, la variable todav√≠a est√° all√≠:\nroot@envlab: / # bash -l 4df007c4e761:/# echo $myvar myvalue 4df007c4e761:/# Incluso si cambiamos de usuario y shell, la variable se encuentra ah√≠:\n4df007c4e761:/# su -s /bin/sh bin 4df007c4e761:/$ id uid=1(bin) gid=1(bin) groups=1(bin),1(bin),2(daemon),3(sys) 4df007c4e761:/$ echo $myvar myvalue Sin embargo, como podemos entender, esto podr√≠a tener algunos efectos secundarios muy peligrosos, por esta raz√≥n, muchos demonios que se ejecutan en el sistema eligen borrar el entorno para procesos posteriores (por ejemplo, php-fpm que tiene clear_env = yes por defecto). Esta es la raz√≥n por la que no se puede acceder a ETSCTF_FLAG cuando se obtiene shell como www-data.\nComo obtenerlas Entonces, vayamos a la parte jugosa sobre c√≥mo encontrar y mostrar los valores de estas variables.\nprintenv - imprime todo o parte del entorno El comando printenv se puede usar para ver las variables actuales definidas en el entorno.\nroot@envlab: / # printenv HOSTNAME=envlab PWD=/ HOME=/root _BASH_VERSION=5.1.8 _BASH_BASELINE=5.1 _BASH_LATEST_PATCH=8 TERM=xterm SHLVL=1 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin _=/bin/printenv root@envlab: / #  env - imprime el entorno o ejecuta un programa con un entorno modificado Los comandos env y printenv se comportan exactamente igual cuando se usan sin par√°metros. Sin embargo, env tambi√©n se puede usar para ejecutar un comando con un entorno modificado.\n Imprimir le ambiente actual.  root@envlab: / # env HOSTNAME=envlab PWD=/ HOME=/root _BASH_VERSION=5.1.8 _BASH_BASELINE=5.1 _BASH_LATEST_PATCH=8 TERM=xterm SHLVL=1 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin _=/usr/bin/env root@envlab: / # Reiniciar el entorno y ejecutar /usr/bin/env para imprimir el entorno y ver que est√° vac√≠o.  root@envlab: / # env -i /usr/bin/env  root@envlab: / #  Reiniciar el entorno y ejecutar /usr/local/bin/bash. Lo que obtenemos son las variables que bash define por defecto.  root@envlab: / # env -i /usr/local/bin/bash root@envlab: / # env PWD=/ SHLVL=1 _=/usr/bin/env root@envlab: / #  Ejecutar bash con la variable $HOME modificada.  root@envlab: / # env -i HOME=/home /usr/local/bin/bash root@envlab: / # echo $HOME /home root@envlab: / # env PWD=/ HOME=/home SHLVL=1 _=/usr/bin/env set BUILTIN - muestra o establece variables y funciones de shell Sin opciones, el nombre y el valor de cada variable se muestran en un formato que se puede reutilizar como entrada para configurar o restablecer las variables configuradas actualmente. Las variables de solo lectura no se pueden restablecer.\nWithout options, the name and value of each shell variable are displayed in a format that can be reused as input for setting or resetting the currently-set variables. Read-only variables cannot be reset.\nEste es un comando incorporado que se usa para definir y/o imprimir variables y funciones espec√≠ficas de la shell.\nEjecutando solo set, devuelve muchas m√°s variables que antes.\nroot@envlab: / # set BASH=/usr/local/bin/bash BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extquote:force_fignore:globasciiranges:hostcomplete:interactive_comments:progcomp:promptvars:sourcepath BASH_ALIASES=() BASH_ARGC=([0]=\u0026#34;0\u0026#34;) BASH_ARGV=() BASH_CMDS=() BASH_LINENO=() BASH_SOURCE=() BASH_VERSINFO=([0]=\u0026#34;5\u0026#34; [1]=\u0026#34;1\u0026#34; [2]=\u0026#34;8\u0026#34; [3]=\u0026#34;1\u0026#34; [4]=\u0026#34;release\u0026#34; [5]=\u0026#34;x86_64-pc-linux-musl\u0026#34;) BASH_VERSION=\u0026#39;5.1.8(1)-release\u0026#39; COLUMNS=211 DIRSTACK=() EUID=0 GROUPS=() HISTFILE=/root/.bash_history HISTFILESIZE=500 HISTSIZE=500 HOME=/root HOSTNAME=envlab HOSTTYPE=x86_64 IFS=$\u0026#39; \\t\\n\u0026#39; LINES=55 MACHTYPE=x86_64-pc-linux-musl MAILCHECK=60 OPTERR=1 OPTIND=1 OSTYPE=linux-musl PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin PPID=0 PS1=\u0026#39;\\s-\\v\\$ \u0026#39; PS2=\u0026#39;\u0026gt; \u0026#39; PS4=\u0026#39;+ \u0026#39; PWD=/ SHELL=/bin/ash SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor SHLVL=1 TERM=xterm UID=0 _=bash _BASH_BASELINE=5.1 _BASH_LATEST_PATCH=8 _BASH_VERSION=5.1.8 Estas son variables que est√°n definidas por nuestra instancia de la shell actual y, a menos que se modifiquen de otra manera, no ser√°n heredadas por los procesos secundarios. Por ejemplo, podemos ver que las variables relacionadas con BASH_ no est√°n configuradas en la invocaci√≥n de la siguiente shell (ash en el siguiente ejemplo).\nroot@envlab: / # /bin/ash / # set HISTFILE=\u0026#39;/root/.ash_history\u0026#39; HOME=\u0026#39;/root\u0026#39; HOSTNAME=\u0026#39;envlab\u0026#39; IFS=\u0026#39; \u0026#39; LINENO=\u0026#39;\u0026#39; OPTIND=\u0026#39;1\u0026#39; PATH=\u0026#39;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#39; PPID=\u0026#39;1\u0026#39; PS1=\u0026#39;\\w \\$ \u0026#39; PS2=\u0026#39;\u0026gt; \u0026#39; PS4=\u0026#39;+ \u0026#39; PWD=\u0026#39;/\u0026#39; SHLVL=\u0026#39;2\u0026#39; TERM=\u0026#39;xterm\u0026#39; _=\u0026#39;/bin/sh\u0026#39; _BASH_BASELINE=\u0026#39;5.1\u0026#39; _BASH_LATEST_PATCH=\u0026#39;8\u0026#39; _BASH_VERSION=\u0026#39;5.1.8\u0026#39; / #  Una ventaja adicional de usar set es que tambi√©n muestra funciones que pueden haber sido definidas.\nroot@envlab: / # function mytest() { ls; } root@envlab: / # set|tail TERM=xterm UID=0 _=set _BASH_BASELINE=5.1 _BASH_LATEST_PATCH=8 _BASH_VERSION=5.1.8 mytest () { ls } root@envlab: / # mytest bin dev etc home lib media mnt opt proc root run sbin srv sys tmp usr var declare / typeset BUILTINS - declarar variables y/o darles atributos Declarar variables y/o darles atributos. Si no se dan nombres, se muestran los valores de las variables. Este comando tiene la capacidad de mostrar y manipular variables, as√≠ como sus atributos (por ejemplo, int, array, exported, etc.).\nSin argumentos, funciona como set, mostrando las variables y funciones de la shell y del entorno.\nenvlab:/# declare BASH=/usr/local/bin/bash BASH_ALIASES=() BASH_ARGC=([0]=\u0026#34;0\u0026#34;) BASH_ARGV=() BASH_CMDS=() BASH_LINENO=() BASH_SOURCE=() . . . Sin embargo, si ejecutamos declare -p tambi√©n podemos ver sus atributos.\nenvlab:/# declare -p declare -- BASH=\u0026#34;/usr/local/bin/bash\u0026#34; declare -i BASHPID declare -A BASH_ALIASES=() declare -a BASH_ARGC=([0]=\u0026#34;0\u0026#34;) declare -x PATH=\u0026#34;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\u0026#34; declare -ir UID=\u0026#34;0\u0026#34; Lo siguiente es lo que significan los atributos de declare:\n -a Cada nombre es una variable indexada en un arreglo. -A Cada nombre es una variable de un arreglo asociativo. -f Usar solo nombres de funciones. -i La variable se trata como un entero. -l Cuando se asigna un valor a la variable, todos los caracteres en may√∫sculas se convierten en min√∫sculas. -n Da a cada nombre el atributo nameref, convirti√©ndolo en una referencia de nombre a otra variable. -r Hacer nombres de solo lectura. -t Dar a cada nombre el atributo de seguimiento. -u Cuando se asigna un valor a la variable, todos los caracteres en min√∫sculas se convierten en may√∫sculas. -x Marcar nombres para exportar a comandos subsecuentes a trav√©s del entorno.  Para obtener m√°s detalles sobre el comando declare, consulte las p√°ginas del manual bash(1) en la secci√≥n SHELL BUILTIN COMMANDS.\nEl comando typeset se comporta de manera muy similar a declare y est√° all√≠ principalmente para la compatibilidad con otros shells. Sin embargo, typeset sin opciones, devuelve todas las variables y funciones de la shell integradas.\nps Todos los comandos anteriores que vimos funcionan en la sesi√≥n de la shell actual, sin embargo, muchas veces nos gustar√≠a ver qu√© variables de entorno se definieron para una aplicaci√≥n que ya se est√° ejecutando, que puede que nosotros hayamos iniciado o no.\nEl comando ps puede ayudar con eso. Este comando proporciona informaci√≥n sobre los procesos en ejecuci√≥n en un sistema, como PID, nombre, tiempo de ejecuci√≥n, memoria utilizada, etc. Al agregar algunas opciones adicionales, podemos ver mucha m√°s informaci√≥n que solo estas. Las opciones que son de nuestro inter√©s, junto con sus significados se pueden encontrar a continuaci√≥n:\n a: Selecciona todos los procesos excepto los dos l√≠deres de sesi√≥n. e: Muestra el entorno despu√©s del comando. w: Amplia salida. Utilice esta opci√≥n dos veces para un ancho ilimitado. f: Jerarqu√≠a de procesos en arte ASCII (forest). u: Muestra formato orientado al usuario.  root@105b97a5ef81:/# ps -afeww UID PID PPID C STIME TTY TIME CMD root 1 0 0 08:48 pts/0 00:00:00 /bin/bash /entrypoint.sh bash root 17 1 0 08:48 pts/0 00:00:00 bash root 93 17 0 08:55 pts/0 00:00:00 ps -feww root@105b97a5ef81:/# ps -aufeww USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.0 17964 2900 pts/0 Ss 08:48 0:00 /bin/bash /entrypoint.sh bash PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=envlab TERM=xterm DEBIAN_FRONTEND=noninteractive HOME=/root root 17 0.0 0.0 18180 3348 pts/0 S 08:48 0:00 bash HOSTNAME=envlab PWD=/ HOME=/root DEBIAN_FRONTEND=noninteractive TERM=xterm SHLVL=1 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin _=/bin/bash root 94 0.0 0.0 36632 2908 pts/0 R+ 08:55 0:00 \\_ ps -ufeww HOSTNAME=envlab PWD=/ HOME=/root DEBIAN_FRONTEND=noninteractive TERM=xterm SHLVL=2 PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin _=/bin/ps Podemos ver en el resultado anterior que obtenemos las variables de entorno tal como existen para cada uno de los comandos en ejecuci√≥n. Sin embargo, hay algunas limitaciones. Si ejecutamos los mismos comandos que un usuario no root, podemos ver que no podemos ver el entorno de los procesos de otros usuarios.\ndatabus@63f7264d374e:/$ ps -aueww USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.0 17964 2992 pts/0 Ss 09:04 0:00 /bin/bash /entrypoint.sh bash root 18 0.0 0.0 18184 3280 pts/0 S 09:04 0:00 bash root 67 0.0 0.0 46844 2772 pts/0 S 09:09 0:00 su - databus databus 68 0.0 0.0 4276 708 pts/0 S 09:09 0:00 -su TERM=xterm PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games MAIL=/var/mail/databus HOME=/ SHELL=/bin/sh USER=databus LOGNAME=databus databus 71 0.0 0.0 18188 3292 pts/0 S 09:09 0:00 bash -l MAIL=/var/mail/databus USER=databus HOME=/ LOGNAME=databus TERM=xterm PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games SHELL=/bin/sh PWD=/ sampleu+ 152 0.8 0.0 18196 3056 pts/1 Ss+ 09:13 0:00 bash databus 160 0.0 0.0 36632 2888 pts/0 R+ 09:14 0:00 ps -aueww USER=databus PWD=/ HOME=/ MAIL=/var/mail/databus SHELL=/bin/sh TERM=xterm SHLVL=1 LOGNAME=databus PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games _=/bin/ps Como podemos ver, los tres primeros procesos pertenecientes a root y sampleuser (una l√≠nea antes de la √∫ltima) no tienen informaci√≥n de entorno incluida en la salida de ps.\n/proc Hay otra forma de obtener el entorno de un proceso en ejecuci√≥n y esto es a trav√©s de /proc, el pseudo-sistema de archivos de informaci√≥n del proceso.\nEl sistema de archivos proc es un pseudo-sistema de archivos que proporciona una interfaz para las estructuras de datos del n√∫cleo. Es com√∫nmente montado en /proc, autom√°ticamente por el sistema.\nEl sistema de archivos proporciona una consulta f√°cil para consultar y manipular las estructuras del kernel como si fueran archivos simples. Para cada proceso en el sistema, hay un directorio correspondiente en /proc/\u0026lt;pid\u0026gt;/ con la informaci√≥n del kernel exportado. Los archivos ubicados debajo de esa carpeta corresponden a diferentes tipos de informaci√≥n del kernel, pero los que nos interesan son environ y cmdline.\n/proc/[pid]/environ: Este archivo contiene el entorno inicial que se estableci√≥ cuando se inici√≥ el programa que se est√° ejecutando actualmente a trav√©s de execve(2). Las entradas est√°n separadas por bytes nulos (\\0), y puede haber un byte nulo en el fin. Por lo tanto, para imprimir el entorno del proceso 1, lo har√≠a.\nroot@63f7264d374e:/# strings /proc/1/environ PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin HOSTNAME=envlab TERM=xterm DEBIAN_FRONTEND=noninteractive HOME=/root /proc/[pid]/cmdline: Este archivo de solo lectura contiene la l√≠nea de comando completa para el proceso, a menos que el proceso sea un zombi. En el √∫ltimo caso, no hay nada en este archivo: es decir, una lectura de este archivo devolver√° 0 caracteres. Los argumentos de la l√≠nea de comandos aparecen en este archivo como un conjunto de cadenas separadas por bytes nulos (\\0), con un byte nulo adicional despu√©s de la √∫ltima cadena.\nroot@63f7264d374e:/# strings /proc/1/cmdline /bin/bash /entrypoint.sh bash La raz√≥n por la que queremos examinar el environ es bastante clara, sin embargo, cmdline puede no serlo. La raz√≥n por la que examinamos ambos archivos es que el comando que se inici√≥ puede incluir variables de entorno en su l√≠nea de comandos.\nTen en cuenta que, dependiendo de la opci√≥n de montaje hidepid=n, el sistema de archivos /proc puede comportarse de manera diferente:\n 0: Todo el mundo puede acceder a todos los directorios /proc/[pid]. Este es el comportamiento tradicional y el predeterminado si no se especifica la opci√≥n de montaje. 1: Los usuarios no pueden acceder a archivos y subdirectorios dentro de ning√∫n directorio /proc/[pid] excepto el suyo propio (los directorios /proc/[pid] permanecen visibles). Los archivos confidenciales como /proc/[pid]/cmdline y /proc/[pid]/status ahora est√°n protegidos contra otros usuarios. Esto hace que sea imposible saber si alg√∫n usuario est√° ejecutando un programa espec√≠fico (siempre y cuando el programa no se revele por su comportamiento). 2: Como en el modo 1, pero adem√°s los directorios /proc/[pid] que pertenecen a otros usuarios se vuelven invisibles. Esto significa que las entradas /proc/[pid] ya no se pueden usar para descubrir los PID en el sistema. Esto no oculta el hecho de que existe un proceso con un valor PID espec√≠fico (se puede aprender por otros medios, por ejemplo, mediante kill -0 $PID), pero oculta el UID y el GID de un proceso, que de otro modo podr√≠an aprenderse empleando stat(2) en un directorio /proc/[pid]. Esto complica enormemente la tarea de un atacante de recopilar informaci√≥n sobre procesos en ejecuci√≥n (por ejemplo, descubrir si alg√∫n demonio se est√° ejecutando con privilegios elevados, si otro usuario est√° ejecutando alg√∫n programa confidencial, si otros usuarios est√°n ejecutando alg√∫n programa, etc.).  ¬øQu√© sigue? Espero que hayas disfrutado de la lectura y que hayas podido aprender algunos trucos adicionales para encontrar variables de entorno para tu sesi√≥n, as√≠ como para ejecutar procesos. Todo lo que tienes que hacer ahora es volver a echoCTF.RED y ver si puedes obtener las variables de entorno de esos objetivos que a√∫n no has terminado üòÇ.\nTen en cuenta que otros shells (ash, ksh, csh, etc.) pueden comportarse de manera diferente con respecto al entorno y las variables y funciones integradas. Los comandos descritos deben ser los mismos en la mayor√≠a, sin embargo, la salida puede diferir. Siempre es una buena idea consultar las p√°ginas del manual del shell respectivo con el que se est√° trabajando antes de probar cosas al azar.\nReferencias  https://docs.oracle.com/cd/E19683-01/817-6958/userconcept-26/index.html https://www.digitalocean.com/community/tutorials/how-to-read-and-set-environmental-and-shell-variables-on-linux https://www.cs.ait.ac.th/~on/O/oreilly/unix/upt/ch06_01.htm  ","permalink":"https://srrequiem.xyz/posts/env-vars/","summary":"Antes de empezar El presente art√≠culo no es de mi autor√≠a si no de Pantelis Roditis (proditis@echothrust.com), esto es solamente una traducci√≥n realizada con el permiso del autor. El art√≠culo original en ingl√©s lo puedes encontrar en el siguiente enlace: Environment variables and how to get them - Pantelis Roditis.\nMe pareci√≥ buena idea traducirlo dado que gracias a su lectura me permiti√≥ encontrar las banderas de entorno de la plataforma echoCTF.","title":"Variables de entorno y c√≥mo obtenerlas"},{"content":"Secronomic√≥n URL: https://srrequiem.xyz/Secronomicon\nGITHUB: https://github.com/srrequiem/Secronomicon\n Libro de notas donde encontrar√°s cada truco/t√©cnica/gu√≠a de hacking que he aprendido y recolectado de CTFS, aplicaciones reales, lectura de writeups y noticias.\n  CTFScrapper GITHUB: https://github.com/srrequiem/CTFScrapper\n Proyecto creado con la intenci√≥n de recopilar los retos presentados en los CTFs mediante la generaci√≥n de un ambiente de trabajo local con los archivos y con la informaci√≥n de los retos.\n  CTF Challenge Compilation GITHUB: https://github.com/srrequiem/CTF-Challenge-Compilation\n Repositorio realizado con la finalidad de tener un compendio de ejercicios de CTFs en los que se ha participado.\n ","permalink":"https://srrequiem.xyz/projects/","summary":"projects","title":"Proyectos personales"}]